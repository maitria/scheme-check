#!/usr/bin/env gsi
; vim:set ft=scheme sts=2 sw=2 et:

(define check1:*source-file* (cadr (command-line)))
(define check1:*ok* #t)

(display check1:*source-file*)
(display ": ")

(load check1:*source-file*)

(define (check1:expectations)
  (define line-number 1)
  (define column-number 0)
  (define expectations '())
  (define this-expectation #f)

  (with-input-from-file check1:*source-file*
    (lambda ()
      (let parse-loop ((c (read-char))
                       (state-stack '(top)))
        (define (next)
          (parse-loop (read-char) state-stack))
        (define (next/push state)
          (parse-loop (read-char) (cons state state-stack)))
        (define (next/pop)
          (parse-loop (read-char) (cdr state-stack)))
        (define (next/replace state)
          (parse-loop (read-char) (cons state (cdr state-stack))))
        (define (in-state . states)
          (memq (car state-stack) states))
        (define (save)
          (set! expectations (cons (list->string (reverse this-expectation)) expectations))
          (set! this-expectation #f))

        (cond
          ((eof-object? c)
           (if (in-state 'expectation)
             (save)))

          ;; Lists
          ((and (in-state 'top)
                (char=? #\( c))
           (next/push 'list))

          ((and (in-state 'list)
                (char=? #\) c))
           (next/pop))

          ;; String literals
          ((and (in-state 'top 'list)
                (char=? #\" c))
           (next/push 'string))
          
          ((and (in-state 'string)
                (char=? #\\ c))
           (read-char)
           (next))

          ((and (in-state 'string)
                (char=? #\" c))
           (next/pop))

          ;; Comments / expectations
          ((and (in-state 'top 'list)
                (char=? #\; c))
           (next/push 'maybe-expectation))

          ((in-state 'maybe-expectation)
           (cond
             ((char=? #\( c)
              (set! this-expectation '(#\())
              (next/replace 'expectation))
             ((char=? #\newline c)
              (next/pop))
             (else
              (next/replace 'comment))))

          ((and (in-state 'comment)
                (char=? #\newline c))
           (next/pop))

          ((and (in-state 'expectation)
                (char=? #\newline c))
           (save)
           (next/pop))

          ((in-state 'expectation)
           (set! this-expectation (cons c this-expectation))
           (next))

          (else
           (next))))))

  (reverse expectations))

(for-each
  (lambda (expectation)
    (with-exception-catcher
      (lambda (e) 
        (set! check1:*ok* #f)
        (display "E"))
      (lambda ()
        (if (eval (with-input-from-string expectation read))
          (display ".")
          (begin
            (set! check1:*ok* #f)
            (display "F"))))))
  (check1:expectations))

(if check1:*ok*
  (display " OK")
  (display " FAILED"))
(newline)
(exit (if check1:*ok*
        0
        1))
