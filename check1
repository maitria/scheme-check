#!/usr/bin/env gsi
; vim:set ft=scheme sts=2 sw=2 et:

(define check1:*source-file* (cadr (command-line)))
(define check1:*ok* #t)

(display check1:*source-file*)
(display ": ")

(load check1:*source-file*)

(define (check1:expectations)
  (define line-number 1)
  (define column-number 0)
  (define expectations '())

  (with-input-from-file check1:*source-file*
    (lambda ()
      (let parse-loop ((c (read-char))
                       (state-stack '(top)))
        (define (next)
          (parse-loop (read-char) state-stack))
        (define (next/push state)
          (parse-loop (read-char) (cons state state-stack)))
        (define (next/pop)
          (parse-loop (read-char) (cdr state-stack)))
        (define (in-state . states)
          (memq (car state-stack) states))

        (cond
          ((eof-object? c)
           #f)

          ;; Lists
          ((and (in-state 'top)
                (char=? #\( c))
           (next/push 'list))

          ((and (in-state 'list)
                (char=? #\) c))
           (next/pop))

          ;; String literals
          ((and (in-state 'top 'list)
                (char=? #\" c))
           (next/push 'string))
          
          ((and (in-state 'string)
                (char=? #\\ c))
           (read-char)
           (next))

          ((and (in-state 'string)
                (char=? #\" c))
           (next/pop))

          ;; Comments
          ((and (in-state 'top 'list)
                (char=? #\; c))
           (next/push 'comment))

          ((and (in-state 'comment)
                (char=? #\newline c))
           (next/pop))

          ((in-state 'comment)
           (display c)
           (next))

          (else
           (next))))))

  (reverse expectations))

(for-each
  (lambda (expectation)
    (with-exception-catcher
      (lambda (e) 
        (set! check1:*ok* #f)
        (display "E"))
      (lambda ()
        (if (eval expectation)
          (display ".")
          (begin
            (set! check1:*ok* #f)
            (display "F"))))))
  (check1:expectations))

(if check1:*ok*
  (display " OK")
  (display " FAILED"))
(newline)
(exit (if check1:*ok*
        0
        1))
